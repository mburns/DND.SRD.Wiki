/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once2);
    module2.exports.strict = wrappy(onceStrict);
    once2.proto = once2(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once2(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once2(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => main_default
});
module.exports = __toCommonJS(main_exports);

// src/settings.ts
var import_obsidian3 = require("obsidian");

// src/auth-modal.ts
var import_obsidian = require("obsidian");
var AuthModal = class extends import_obsidian.Modal {
  constructor(app, verification) {
    super(app);
    this.verification = verification;
  }
  onOpen() {
    this.titleEl.setText("Generate GitHub token");
    this.contentEl.empty();
    const wrapper = this.contentEl.createDiv({ cls: "gh-auth-modal" });
    wrapper.createEl("p", {
      text: "Copy the following code and paste it at the GitHub link below."
    });
    const codeEl = wrapper.createDiv({
      cls: "gh-auth-code-section"
    });
    codeEl.createSpan({
      cls: "auth-code",
      text: this.verification.user_code
    });
    const button = codeEl.createEl("button", {
      attr: { type: "button", "aria-label": "Copy Code" }
    });
    (0, import_obsidian.setIcon)(button, "copy");
    button.addEventListener("click", this.copyToClipboard.bind(this));
    wrapper.createEl("a", {
      href: this.verification.verification_uri,
      text: this.verification.verification_uri
    });
  }
  copyToClipboard() {
    window.navigator.clipboard.writeText(this.verification.user_code);
  }
};

// src/util.ts
function verboseFactory(logLevel) {
  const log = (message, level) => {
    if (level <= logLevel) {
      switch (level) {
        case 0 /* Error */:
          console.error(message);
          break;
        case 1 /* Warn */:
          console.warn(message);
          break;
        case 2 /* Info */:
          console.info(message);
          break;
        case 3 /* Debug */:
          console.debug(message);
          break;
      }
    }
  };
  return {
    log,
    error: (message) => log(message, 0 /* Error */),
    warn: (message) => log(message, 1 /* Warn */),
    info: (message) => log(message, 2 /* Info */),
    debug: (message) => log(message, 3 /* Debug */)
  };
}
function titleCase(value) {
  const words = value.split(/[-_]/);
  return words.map((w) => {
    var _a;
    return ((_a = w.charAt(0)) == null ? void 0 : _a.toUpperCase()) + w.slice(1);
  }).join(" ");
}
function sanitizeObject(params, usableFieldMap) {
  const usableFields = Object.entries(usableFieldMap).filter(([_, value]) => value).map(([key, _]) => key);
  const result = {};
  for (const field of usableFields) {
    if (params[field] !== void 0) {
      result[field] = params[field];
    }
  }
  return result;
}
function getProp(value, prop) {
  var _a;
  if (!prop.includes(".")) {
    return (_a = value[prop]) != null ? _a : null;
  }
  const parts = prop.split(".");
  let val = value;
  for (const part of parts) {
    try {
      val = val[part];
    } catch (err) {
      return null;
    }
  }
  return val != null ? val : null;
}
var n = "numeric";
var DateFormat = {
  DATE_SHORT: new Intl.DateTimeFormat(void 0, {
    year: n,
    month: n,
    day: n
  })
};
var RequestError = class {
  constructor(originalError) {
    this.originalError = originalError;
    this.name = originalError.name;
    this.stack = originalError.stack;
    this.message = originalError.message;
    this.headers = originalError.headers;
    this.status = originalError.status;
  }
};

// node_modules/universal-user-agent/dist-web/index.js
function getUserAgent() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/@octokit/endpoint/dist-web/index.js
var VERSION = "9.0.4";
var userAgent = `octokit-endpoint.js/${VERSION} ${getUserAgent()}`;
var DEFAULTS = {
  method: "GET",
  baseUrl: "https://api.github.com",
  headers: {
    accept: "application/vnd.github.v3+json",
    "user-agent": userAgent
  },
  mediaType: {
    format: ""
  }
};
function lowercaseKeys(object) {
  if (!object) {
    return {};
  }
  return Object.keys(object).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object[key];
    return newObj;
  }, {});
}
function isPlainObject(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
function mergeDeep(defaults, options) {
  const result = Object.assign({}, defaults);
  Object.keys(options).forEach((key) => {
    if (isPlainObject(options[key])) {
      if (!(key in defaults))
        Object.assign(result, { [key]: options[key] });
      else
        result[key] = mergeDeep(defaults[key], options[key]);
    } else {
      Object.assign(result, { [key]: options[key] });
    }
  });
  return result;
}
function removeUndefinedProperties(obj) {
  for (const key in obj) {
    if (obj[key] === void 0) {
      delete obj[key];
    }
  }
  return obj;
}
function merge(defaults, route, options) {
  var _a;
  if (typeof route === "string") {
    let [method, url] = route.split(" ");
    options = Object.assign(url ? { method, url } : { url: method }, options);
  } else {
    options = Object.assign({}, route);
  }
  options.headers = lowercaseKeys(options.headers);
  removeUndefinedProperties(options);
  removeUndefinedProperties(options.headers);
  const mergedOptions = mergeDeep(defaults || {}, options);
  if (options.url === "/graphql") {
    if (defaults && ((_a = defaults.mediaType.previews) == null ? void 0 : _a.length)) {
      mergedOptions.mediaType.previews = defaults.mediaType.previews.filter(
        (preview) => !mergedOptions.mediaType.previews.includes(preview)
      ).concat(mergedOptions.mediaType.previews);
    }
    mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
  }
  return mergedOptions;
}
function addQueryParameters(url, parameters) {
  const separator = /\?/.test(url) ? "&" : "?";
  const names = Object.keys(parameters);
  if (names.length === 0) {
    return url;
  }
  return url + separator + names.map((name) => {
    if (name === "q") {
      return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
    }
    return `${name}=${encodeURIComponent(parameters[name])}`;
  }).join("&");
}
var urlVariableRegex = /\{[^}]+\}/g;
function removeNonChars(variableName) {
  return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
}
function extractUrlVariableNames(url) {
  const matches = url.match(urlVariableRegex);
  if (!matches) {
    return [];
  }
  return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
}
function omit(object, keysToOmit) {
  const result = { __proto__: null };
  for (const key of Object.keys(object)) {
    if (keysToOmit.indexOf(key) === -1) {
      result[key] = object[key];
    }
  }
  return result;
}
function encodeReserved(str) {
  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
    if (!/%[0-9A-Fa-f]/.test(part)) {
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }
    return part;
  }).join("");
}
function encodeUnreserved(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
    return "%" + c.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeValue(operator, value, key) {
  value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
  if (key) {
    return encodeUnreserved(key) + "=" + value;
  } else {
    return value;
  }
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isKeyOperator(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}
function getValues(context, operator, key, modifier) {
  var value = context[key], result = [];
  if (isDefined(value) && value !== "") {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      value = value.toString();
      if (modifier && modifier !== "*") {
        value = value.substring(0, parseInt(modifier, 10));
      }
      result.push(
        encodeValue(operator, value, isKeyOperator(operator) ? key : "")
      );
    } else {
      if (modifier === "*") {
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            result.push(
              encodeValue(operator, value2, isKeyOperator(operator) ? key : "")
            );
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              result.push(encodeValue(operator, value[k], k));
            }
          });
        }
      } else {
        const tmp = [];
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            tmp.push(encodeValue(operator, value2));
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              tmp.push(encodeUnreserved(k));
              tmp.push(encodeValue(operator, value[k].toString()));
            }
          });
        }
        if (isKeyOperator(operator)) {
          result.push(encodeUnreserved(key) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined(value)) {
        result.push(encodeUnreserved(key));
      }
    } else if (value === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved(key) + "=");
    } else if (value === "") {
      result.push("");
    }
  }
  return result;
}
function parseUrl(template) {
  return {
    expand: expand.bind(null, template)
  };
}
function expand(template, context) {
  var operators = ["+", "#", ".", "/", ";", "?", "&"];
  template = template.replace(
    /\{([^\{\}]+)\}|([^\{\}]+)/g,
    function(_, expression, literal) {
      if (expression) {
        let operator = "";
        const values = [];
        if (operators.indexOf(expression.charAt(0)) !== -1) {
          operator = expression.charAt(0);
          expression = expression.substr(1);
        }
        expression.split(/,/g).forEach(function(variable) {
          var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
          values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
        });
        if (operator && operator !== "+") {
          var separator = ",";
          if (operator === "?") {
            separator = "&";
          } else if (operator !== "#") {
            separator = operator;
          }
          return (values.length !== 0 ? operator : "") + values.join(separator);
        } else {
          return values.join(",");
        }
      } else {
        return encodeReserved(literal);
      }
    }
  );
  if (template === "/") {
    return template;
  } else {
    return template.replace(/\/$/, "");
  }
}
function parse(options) {
  var _a;
  let method = options.method.toUpperCase();
  let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters = omit(options, [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "mediaType"
  ]);
  const urlVariableNames = extractUrlVariableNames(url);
  url = parseUrl(url).expand(parameters);
  if (!/^http/.test(url)) {
    url = options.baseUrl + url;
  }
  const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
  const remainingParameters = omit(parameters, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      headers.accept = headers.accept.split(/,/).map(
        (format) => format.replace(
          /application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/,
          `application/vnd$1$2.${options.mediaType.format}`
        )
      ).join(",");
    }
    if (url.endsWith("/graphql")) {
      if ((_a = options.mediaType.previews) == null ? void 0 : _a.length) {
        const previewsFromAcceptHeader = headers.accept.match(/[\w-]+(?=-preview)/g) || [];
        headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
          const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
          return `application/vnd.github.${preview}-preview${format}`;
        }).join(",");
      }
    }
  }
  if (["GET", "HEAD"].includes(method)) {
    url = addQueryParameters(url, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      }
    }
  }
  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  }
  if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
    body = "";
  }
  return Object.assign(
    { method, url, headers },
    typeof body !== "undefined" ? { body } : null,
    options.request ? { request: options.request } : null
  );
}
function endpointWithDefaults(defaults, route, options) {
  return parse(merge(defaults, route, options));
}
function withDefaults(oldDefaults, newDefaults) {
  const DEFAULTS2 = merge(oldDefaults, newDefaults);
  const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
  return Object.assign(endpoint2, {
    DEFAULTS: DEFAULTS2,
    defaults: withDefaults.bind(null, DEFAULTS2),
    merge: merge.bind(null, DEFAULTS2),
    parse
  });
}
var endpoint = withDefaults(null, DEFAULTS);

// node_modules/deprecation/dist-web/index.js
var Deprecation = class extends Error {
  constructor(message) {
    super(message);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = "Deprecation";
  }
};

// node_modules/@octokit/request-error/dist-web/index.js
var import_once = __toESM(require_once());
var logOnceCode = (0, import_once.default)((deprecation) => console.warn(deprecation));
var logOnceHeaders = (0, import_once.default)((deprecation) => console.warn(deprecation));
var RequestError2 = class extends Error {
  constructor(message, statusCode, options) {
    super(message);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = "HttpError";
    this.status = statusCode;
    let headers;
    if ("headers" in options && typeof options.headers !== "undefined") {
      headers = options.headers;
    }
    if ("response" in options) {
      this.response = options.response;
      headers = options.response.headers;
    }
    const requestCopy = Object.assign({}, options.request);
    if (options.request.headers.authorization) {
      requestCopy.headers = Object.assign({}, options.request.headers, {
        authorization: options.request.headers.authorization.replace(
          / .*$/,
          " [REDACTED]"
        )
      });
    }
    requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
    this.request = requestCopy;
    Object.defineProperty(this, "code", {
      get() {
        logOnceCode(
          new Deprecation(
            "[@octokit/request-error] `error.code` is deprecated, use `error.status`."
          )
        );
        return statusCode;
      }
    });
    Object.defineProperty(this, "headers", {
      get() {
        logOnceHeaders(
          new Deprecation(
            "[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`."
          )
        );
        return headers || {};
      }
    });
  }
};

// node_modules/@octokit/request/dist-web/index.js
var VERSION2 = "8.1.6";
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
function getBufferResponse(response) {
  return response.arrayBuffer();
}
function fetchWrapper(requestOptions) {
  var _a, _b, _c;
  const log = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;
  const parseSuccessResponseBody = ((_a = requestOptions.request) == null ? void 0 : _a.parseSuccessResponseBody) !== false;
  if (isPlainObject2(requestOptions.body) || Array.isArray(requestOptions.body)) {
    requestOptions.body = JSON.stringify(requestOptions.body);
  }
  let headers = {};
  let status;
  let url;
  let { fetch } = globalThis;
  if ((_b = requestOptions.request) == null ? void 0 : _b.fetch) {
    fetch = requestOptions.request.fetch;
  }
  if (!fetch) {
    throw new Error(
      "fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing"
    );
  }
  return fetch(requestOptions.url, {
    method: requestOptions.method,
    body: requestOptions.body,
    headers: requestOptions.headers,
    signal: (_c = requestOptions.request) == null ? void 0 : _c.signal,
    // duplex must be set if request.body is ReadableStream or Async Iterables.
    // See https://fetch.spec.whatwg.org/#dom-requestinit-duplex.
    ...requestOptions.body && { duplex: "half" }
  }).then(async (response) => {
    url = response.url;
    status = response.status;
    for (const keyAndValue of response.headers) {
      headers[keyAndValue[0]] = keyAndValue[1];
    }
    if ("deprecation" in headers) {
      const matches = headers.link && headers.link.match(/<([^>]+)>; rel="deprecation"/);
      const deprecationLink = matches && matches.pop();
      log.warn(
        `[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`
      );
    }
    if (status === 204 || status === 205) {
      return;
    }
    if (requestOptions.method === "HEAD") {
      if (status < 400) {
        return;
      }
      throw new RequestError2(response.statusText, status, {
        response: {
          url,
          status,
          headers,
          data: void 0
        },
        request: requestOptions
      });
    }
    if (status === 304) {
      throw new RequestError2("Not modified", status, {
        response: {
          url,
          status,
          headers,
          data: await getResponseData(response)
        },
        request: requestOptions
      });
    }
    if (status >= 400) {
      const data = await getResponseData(response);
      const error = new RequestError2(toErrorMessage(data), status, {
        response: {
          url,
          status,
          headers,
          data
        },
        request: requestOptions
      });
      throw error;
    }
    return parseSuccessResponseBody ? await getResponseData(response) : response.body;
  }).then((data) => {
    return {
      status,
      url,
      headers,
      data
    };
  }).catch((error) => {
    if (error instanceof RequestError2)
      throw error;
    else if (error.name === "AbortError")
      throw error;
    let message = error.message;
    if (error.name === "TypeError" && "cause" in error) {
      if (error.cause instanceof Error) {
        message = error.cause.message;
      } else if (typeof error.cause === "string") {
        message = error.cause;
      }
    }
    throw new RequestError2(message, 500, {
      request: requestOptions
    });
  });
}
async function getResponseData(response) {
  const contentType = response.headers.get("content-type");
  if (/application\/json/.test(contentType)) {
    return response.json().catch(() => response.text()).catch(() => "");
  }
  if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
    return response.text();
  }
  return getBufferResponse(response);
}
function toErrorMessage(data) {
  if (typeof data === "string")
    return data;
  if ("message" in data) {
    if (Array.isArray(data.errors)) {
      return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}`;
    }
    return data.message;
  }
  return `Unknown error: ${JSON.stringify(data)}`;
}
function withDefaults2(oldEndpoint, newDefaults) {
  const endpoint2 = oldEndpoint.defaults(newDefaults);
  const newApi = function(route, parameters) {
    const endpointOptions = endpoint2.merge(route, parameters);
    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper(endpoint2.parse(endpointOptions));
    }
    const request2 = (route2, parameters2) => {
      return fetchWrapper(
        endpoint2.parse(endpoint2.merge(route2, parameters2))
      );
    };
    Object.assign(request2, {
      endpoint: endpoint2,
      defaults: withDefaults2.bind(null, endpoint2)
    });
    return endpointOptions.request.hook(request2, endpointOptions);
  };
  return Object.assign(newApi, {
    endpoint: endpoint2,
    defaults: withDefaults2.bind(null, endpoint2)
  });
}
var request = withDefaults2(endpoint, {
  headers: {
    "user-agent": `octokit-request.js/${VERSION2} ${getUserAgent()}`
  }
});

// node_modules/@octokit/oauth-methods/dist-src/utils.js
function requestToOAuthBaseUrl(request2) {
  const endpointDefaults = request2.endpoint.DEFAULTS;
  return /^https:\/\/(api\.)?github\.com$/.test(endpointDefaults.baseUrl) ? "https://github.com" : endpointDefaults.baseUrl.replace("/api/v3", "");
}
async function oauthRequest(request2, route, parameters) {
  const withOAuthParameters = {
    baseUrl: requestToOAuthBaseUrl(request2),
    headers: {
      accept: "application/json"
    },
    ...parameters
  };
  const response = await request2(route, withOAuthParameters);
  if ("error" in response.data) {
    const error = new RequestError2(
      `${response.data.error_description} (${response.data.error}, ${response.data.error_uri})`,
      400,
      {
        request: request2.endpoint.merge(
          route,
          withOAuthParameters
        ),
        headers: response.headers
      }
    );
    error.response = response;
    throw error;
  }
  return response;
}

// node_modules/@octokit/oauth-methods/dist-src/create-device-code.js
async function createDeviceCode(options) {
  const request2 = options.request || /* istanbul ignore next: we always pass a custom request in tests */
  request;
  const parameters = {
    client_id: options.clientId
  };
  if ("scopes" in options && Array.isArray(options.scopes)) {
    parameters.scope = options.scopes.join(" ");
  }
  return oauthRequest(request2, "POST /login/device/code", parameters);
}

// node_modules/@octokit/oauth-methods/dist-src/exchange-device-code.js
async function exchangeDeviceCode(options) {
  const request2 = options.request || /* istanbul ignore next: we always pass a custom request in tests */
  request;
  const response = await oauthRequest(
    request2,
    "POST /login/oauth/access_token",
    {
      client_id: options.clientId,
      device_code: options.code,
      grant_type: "urn:ietf:params:oauth:grant-type:device_code"
    }
  );
  const authentication = {
    clientType: options.clientType,
    clientId: options.clientId,
    token: response.data.access_token,
    scopes: response.data.scope.split(/\s+/).filter(Boolean)
  };
  if ("clientSecret" in options) {
    authentication.clientSecret = options.clientSecret;
  }
  if (options.clientType === "github-app") {
    if ("refresh_token" in response.data) {
      const apiTimeInMs = new Date(response.headers.date).getTime();
      authentication.refreshToken = response.data.refresh_token, authentication.expiresAt = toTimestamp(
        apiTimeInMs,
        response.data.expires_in
      ), authentication.refreshTokenExpiresAt = toTimestamp(
        apiTimeInMs,
        response.data.refresh_token_expires_in
      );
    }
    delete authentication.scopes;
  }
  return { ...response, authentication };
}
function toTimestamp(apiTimeInMs, expirationInSeconds) {
  return new Date(apiTimeInMs + expirationInSeconds * 1e3).toISOString();
}

// node_modules/@octokit/auth-oauth-device/dist-web/index.js
async function getOAuthAccessToken(state, options) {
  const cachedAuthentication = getCachedAuthentication(state, options.auth);
  if (cachedAuthentication)
    return cachedAuthentication;
  const { data: verification } = await createDeviceCode({
    clientType: state.clientType,
    clientId: state.clientId,
    request: options.request || state.request,
    // @ts-expect-error the extra code to make TS happy is not worth it
    scopes: options.auth.scopes || state.scopes
  });
  await state.onVerification(verification);
  const authentication = await waitForAccessToken(
    options.request || state.request,
    state.clientId,
    state.clientType,
    verification
  );
  state.authentication = authentication;
  return authentication;
}
function getCachedAuthentication(state, auth22) {
  if (auth22.refresh === true)
    return false;
  if (!state.authentication)
    return false;
  if (state.clientType === "github-app") {
    return state.authentication;
  }
  const authentication = state.authentication;
  const newScope = ("scopes" in auth22 && auth22.scopes || state.scopes).join(
    " "
  );
  const currentScope = authentication.scopes.join(" ");
  return newScope === currentScope ? authentication : false;
}
async function wait(seconds) {
  await new Promise((resolve) => setTimeout(resolve, seconds * 1e3));
}
async function waitForAccessToken(request2, clientId, clientType, verification) {
  try {
    const options = {
      clientId,
      request: request2,
      code: verification.device_code
    };
    const { authentication } = clientType === "oauth-app" ? await exchangeDeviceCode({
      ...options,
      clientType: "oauth-app"
    }) : await exchangeDeviceCode({
      ...options,
      clientType: "github-app"
    });
    return {
      type: "token",
      tokenType: "oauth",
      ...authentication
    };
  } catch (error) {
    if (!error.response)
      throw error;
    const errorType = error.response.data.error;
    if (errorType === "authorization_pending") {
      await wait(verification.interval);
      return waitForAccessToken(request2, clientId, clientType, verification);
    }
    if (errorType === "slow_down") {
      await wait(verification.interval + 5);
      return waitForAccessToken(request2, clientId, clientType, verification);
    }
    throw error;
  }
}
async function auth(state, authOptions) {
  return getOAuthAccessToken(state, {
    auth: authOptions
  });
}
async function hook(state, request2, route, parameters) {
  let endpoint2 = request2.endpoint.merge(
    route,
    parameters
  );
  if (/\/login\/(oauth\/access_token|device\/code)$/.test(endpoint2.url)) {
    return request2(endpoint2);
  }
  const { token } = await getOAuthAccessToken(state, {
    request: request2,
    auth: { type: "oauth" }
  });
  endpoint2.headers.authorization = `token ${token}`;
  return request2(endpoint2);
}
var VERSION3 = "6.0.1";
function createOAuthDeviceAuth(options) {
  const requestWithDefaults = options.request || request.defaults({
    headers: {
      "user-agent": `octokit-auth-oauth-device.js/${VERSION3} ${getUserAgent()}`
    }
  });
  const { request: request2 = requestWithDefaults, ...otherOptions } = options;
  const state = options.clientType === "github-app" ? {
    ...otherOptions,
    clientType: "github-app",
    request: request2
  } : {
    ...otherOptions,
    clientType: "oauth-app",
    request: request2,
    scopes: options.scopes || []
  };
  if (!options.clientId) {
    throw new Error(
      '[@octokit/auth-oauth-device] "clientId" option must be set (https://github.com/octokit/auth-oauth-device.js#usage)'
    );
  }
  if (!options.onVerification) {
    throw new Error(
      '[@octokit/auth-oauth-device] "onVerification" option must be a function (https://github.com/octokit/auth-oauth-device.js#usage)'
    );
  }
  return Object.assign(auth.bind(null, state), {
    hook: hook.bind(null, state)
  });
}

// src/github/auth.ts
var import_obsidian2 = require("obsidian");
function getHeaders(headers) {
  if (!headers) {
    return void 0;
  }
  if (headers instanceof Headers) {
    const result = {};
    headers.forEach((value, key) => {
      result[key] = value;
    });
    return result;
  }
  if (Array.isArray(headers)) {
    throw new Error("Got array headers, we don't know what to do with this yet.");
  }
  return headers;
}
function getBody(body) {
  if (!body) {
    return void 0;
  }
  if (body instanceof ArrayBuffer || typeof body === "string") {
    return body;
  }
  console.warn(`Got an unknown body parameter type, trying to stringify it.`);
  console.warn(body);
  try {
    return JSON.stringify(body);
  } catch (e) {
    console.error("Could not stringify body parameter.");
    return void 0;
  }
}
async function doFetch(url, options) {
  if (typeof url !== "string") {
    throw new Error("Something has gone horribly wrong and fetch has received unexpected arguments.");
  }
  if (options === void 0) {
    throw new Error("No options given to fetch.");
  }
  const headers = getHeaders(options.headers);
  const contentType = headers == null ? void 0 : headers["Content-Type"];
  const params = {
    url,
    headers,
    method: options.method,
    body: getBody(options.body),
    contentType
  };
  const result = await (0, import_obsidian2.requestUrl)(params);
  const partialResult = {
    ...result,
    url,
    headers: new Headers(result.headers),
    arrayBuffer: () => Promise.resolve(result.arrayBuffer),
    text: () => Promise.resolve(result.text),
    json: () => Promise.resolve(result.json)
  };
  return partialResult;
}
var auth2 = (verificationHandler) => createOAuthDeviceAuth({
  clientType: "oauth-app",
  clientId: "baf0370cb98e1387d244",
  scopes: ["repo"],
  onVerification: verificationHandler,
  request: request.defaults({
    request: { fetch: doFetch }
  })
});

// src/settings.ts
var DEFAULT_SETTINGS = {
  accounts: [],
  logLevel: 0 /* Error */
};
var GithubLinkPluginSettingsTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.app = app;
    this.plugin = plugin;
    this.authModal = null;
    this.newAccount = null;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "GitHub authentication" });
    containerEl.createEl("p", {
      text: "No authentication is required to reference public repositories. Providing a token allows referencing private repos, but the token is stored in plain text. You can create multiple accounts for multiple tokens."
    });
    new import_obsidian3.Setting(containerEl).setName("Add account").addButton((button) => {
      button.setButtonText("");
      button.setIcon("plus");
      button.setTooltip("Add Account");
      button.onClick(() => {
        this.newAccount = { id: crypto.randomUUID(), name: "", orgs: [], token: "" };
        this.display();
      });
    });
    new import_obsidian3.Setting(containerEl).setName("Default account").setDesc("The account that will be used if no other users or organizations match.").addDropdown((dropdown) => {
      var _a;
      const options = PluginSettings.accounts.reduce((acc, account) => {
        acc[account.id] = account.name;
        return acc;
      }, {});
      dropdown.addOptions(options);
      dropdown.setValue((_a = PluginSettings.defaultAccount) != null ? _a : "");
      dropdown.onChange(async (value) => {
        const selectedAccount = PluginSettings.accounts.find((acc) => acc.id === value);
        if (selectedAccount) {
          PluginSettings.defaultAccount = selectedAccount.id;
          await this.saveSettings();
        }
      });
    });
    if (this.newAccount !== null) {
      const accountContainer = containerEl.createDiv();
      const header = accountContainer.createEl("h3", { text: "New account" });
      new import_obsidian3.Setting(accountContainer).setName("Account name").setDesc("Required.").addText((text) => {
        text.setValue(this.newAccount.name);
        text.onChange((value) => {
          this.newAccount.name = value;
          header.setText(value != null ? value : "New account");
        });
      }).addButton((button) => {
        button.setIcon("trash");
        button.setTooltip("Delete account");
        button.onClick(() => {
          this.newAccount = null;
          this.display();
        });
      });
      new import_obsidian3.Setting(accountContainer).setName("Orgs and users").setDesc(
        "A comma separated list of the GitHub organizations and users this account should be used for. Optional."
      ).addTextArea((text) => {
        text.setValue(this.newAccount.orgs.join(", "));
        text.onChange((value) => {
          this.newAccount.orgs = value.split(",");
        });
      });
      new import_obsidian3.Setting(accountContainer).setName("Token").setDesc(
        "A GitHub token, which can be generated automatically (recommended) or by creating a personal access token (not recommended unless org does not allow OAuth tokens). Required."
      ).addButton((button) => {
        button.setButtonText("Generate Token");
        button.onClick(async () => {
          var _a;
          const authResult = await auth2(this.tokenVerification.bind(this))({
            type: "oauth"
          });
          (_a = this.authModal) == null ? void 0 : _a.close();
          this.authModal = null;
          this.newAccount.token = authResult.token;
          this.display();
        });
      }).addText((text) => {
        text.setPlaceholder("Personal Access Token / OAuth Token");
        text.setValue(this.newAccount.token);
        text.onChange((value) => {
          this.newAccount.token = value;
        });
      });
      new import_obsidian3.Setting(accountContainer).addButton((button) => {
        button.setTooltip("Save account");
        button.setIcon("save");
        button.onClick(async () => {
          if (!this.newAccount || !this.newAccount.name || !this.newAccount.token) {
            return;
          }
          PluginSettings.accounts.unshift(this.newAccount);
          await this.saveSettings();
          this.newAccount = null;
          this.display();
        });
      });
    }
    for (const account of PluginSettings.accounts) {
      const accountContainer = containerEl.createDiv();
      accountContainer.createEl("h3", { text: account.name });
      new import_obsidian3.Setting(accountContainer).setName("Account name").addText((text) => {
        text.setValue(account.name);
        text.onChange((value) => {
          account.name = value;
          this.saveSettings();
        });
      }).addButton((button) => {
        button.setIcon("trash");
        button.setTooltip("Delete account");
        button.onClick(async () => {
          PluginSettings.accounts.remove(account);
          await this.saveSettings();
          this.display();
        });
      });
      new import_obsidian3.Setting(accountContainer).setName("Orgs and users").setDesc("A comma separated list of the GitHub organizations and users this account should be used for.").addTextArea((text) => {
        text.setValue(account.orgs.join(", "));
        text.onChange((value) => {
          account.orgs = value.split(",").map((org) => org.trim());
          this.saveSettings();
        });
      });
      new import_obsidian3.Setting(accountContainer).setName("Token").setDesc(
        "A GitHub token, which can be generated automatically (recommended) or by creating a personal access token (not recommended unless org does not allow OAuth tokens)."
      ).addButton((button) => {
        button.setButtonText("Generate Token");
        button.onClick(async () => {
          var _a;
          const authResult = await auth2(this.tokenVerification.bind(this))({
            type: "oauth"
          });
          (_a = this.authModal) == null ? void 0 : _a.close();
          this.authModal = null;
          account.token = authResult.token;
          await this.saveSettings();
          this.display();
        });
      }).addText((text) => {
        text.setPlaceholder("Personal Access Token / OAuth Token");
        text.setValue(account.token);
        text.onChange((value) => {
          account.token = value;
          this.saveSettings();
        });
      });
    }
  }
  saveSettings() {
    return this.plugin.saveData(PluginSettings);
  }
  tokenVerification(verification) {
    this.authModal = new AuthModal(this.app, verification);
    this.authModal.open();
  }
};

// src/github/response.ts
function getSearchResultIssueStatus(issue) {
  var _a;
  if (((_a = issue.pull_request) == null ? void 0 : _a.merged_at) || issue.state_reason === "completed") {
    return "done" /* Done */;
  } else if (issue.closed_at || issue.state === "closed") {
    return "closed" /* Closed */;
  } else {
    return "open" /* Open */;
  }
}
function getPRStatus(pr) {
  if (pr.merged) {
    return "done" /* Done */;
  } else if (pr.closed_at) {
    return "closed" /* Closed */;
  } else {
    return "open" /* Open */;
  }
}

// src/github/api.ts
var import_obsidian4 = require("obsidian");
var baseApi = "https://api.github.com";
function addParams(href, params) {
  const url = new URL(href);
  for (const [key, value] of Object.entries(params)) {
    url.searchParams.set(key, `${value}`);
  }
  return url.toString();
}
async function githubRequest(config, token) {
  if (!config.headers) {
    config.headers = {};
  }
  config.headers.Accept = "application/vnd.github+json";
  config.headers["X-GitHub-Api-Version"] = "2022-11-28";
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  Logger.debug(config);
  try {
    const response = await (0, import_obsidian4.requestUrl)(config);
    Logger.debug(response);
    return response;
  } catch (err) {
    throw new RequestError(err);
  }
}
async function getIssue(org, repo, issue, token) {
  const result = await githubRequest({ url: `${baseApi}/repos/${org}/${repo}/issues/${issue}` }, token);
  return result.json;
}
async function listIssuesForToken(params = {}, token) {
  const url = addParams(`${baseApi}/issues`, params);
  const result = await githubRequest({ url }, token);
  return result.json;
}
async function listIssuesForRepo(org, repo, params = {}, token) {
  const url = addParams(`${baseApi}/repos/${org}/${repo}/issues`, params);
  const result = await githubRequest({ url }, token);
  return result.json;
}
async function getPullRequest(org, repo, pr, token) {
  const result = await githubRequest(
    {
      url: `${baseApi}/repos/${org}/${repo}/pulls/${pr}`
    },
    token
  );
  return result.json;
}
async function listPullRequestsForRepo(org, repo, params = {}, token) {
  const url = addParams(`${baseApi}/repos/${org}/${repo}/pulls`, params);
  const result = await githubRequest({ url }, token);
  return result.json;
}
async function getCode(org, repo, path, branch, token) {
  const result = await githubRequest(
    {
      url: `${baseApi}/repos/${org}/${repo}/contents/${path}?ref=${branch}`
    },
    token
  );
  return result.json;
}
async function searchRepos(query, token) {
  const result = await githubRequest({ url: `${baseApi}/search/repositories?q=${encodeURIComponent(query)}` }, token);
  return result.json;
}
async function searchIssues(query, token) {
  const result = await githubRequest({ url: `${baseApi}/search/issues?q=${encodeURIComponent(query)}` }, token);
  return result.json;
}
var api = {
  getIssue,
  listIssuesForToken,
  listIssuesForRepo,
  getPullRequest,
  listPullRequestsForRepo,
  getCode,
  searchIssues,
  searchRepos
};

// src/github/cache.ts
var CacheEntry = class {
  constructor(value, created = /* @__PURE__ */ new Date(), ttl = 20) {
    this.value = value;
    this.created = created;
    this.ttl = ttl;
  }
  get expired() {
    const expiry = this.created.getTime() + this.ttl * 60 * 1e3;
    return (/* @__PURE__ */ new Date()).getTime() > expiry;
  }
};
var QueryCache = class {
  constructor() {
    this.issueCache = {};
    this.repoCache = {};
  }
};
var RepoCache = class {
  constructor() {
    this.issueCache = {};
    this.issueListForRepoCache = {};
    this.pullCache = {};
    this.pullListForRepoCache = {};
  }
};
var OrgCache = class {
  constructor() {
    this.repos = {};
    this.issueList = {};
  }
};
var Cache = class {
  constructor() {
    this.generic = {};
    this.orgs = {};
    this.queries = new QueryCache();
  }
  getGeneric(url) {
    var _a;
    return this.getCacheValue((_a = this.generic[url]) != null ? _a : null);
  }
  setGeneric(url, value) {
    this.generic[url] = new CacheEntry(value);
  }
  getIssue(org, repo, issue) {
    var _a;
    const repoCache = this.getRepoCache(org, repo);
    return this.getCacheValue((_a = repoCache.issueCache[issue]) != null ? _a : null);
  }
  setIssue(org, repo, issue) {
    const issueCache = this.getRepoCache(org, repo).issueCache;
    const existingCache = issueCache[issue.id];
    if (existingCache) {
      const now = /* @__PURE__ */ new Date();
      existingCache.created = now;
      existingCache.value = issue;
    } else {
      issueCache[issue.id] = new CacheEntry(issue);
    }
  }
  getIssueList(org, params) {
    var _a;
    const orgCache = this.getOrgCache(org);
    return this.getCacheValue((_a = orgCache.issueList[JSON.stringify(params)]) != null ? _a : null);
  }
  setIssueList(org, params, value) {
    const orgCache = this.getOrgCache(org);
    orgCache.issueList[JSON.stringify(params)] = new CacheEntry(value);
  }
  getIssueListForRepo(org, repo, params) {
    var _a;
    const repoCache = this.getRepoCache(org, repo);
    return this.getCacheValue((_a = repoCache.issueListForRepoCache[JSON.stringify(params)]) != null ? _a : null);
  }
  setIssueListForRepo(org, repo, params, value) {
    const repoCache = this.getRepoCache(org, repo);
    repoCache.issueListForRepoCache[JSON.stringify(params)] = new CacheEntry(value);
  }
  getPullRequest(org, repo, pullRequest) {
    var _a;
    const repoCache = this.getRepoCache(org, repo);
    return this.getCacheValue((_a = repoCache.pullCache[pullRequest]) != null ? _a : null);
  }
  getPullListForRepo(org, repo, params) {
    var _a;
    const repoCache = this.getRepoCache(org, repo);
    return this.getCacheValue((_a = repoCache.pullListForRepoCache[JSON.stringify(params)]) != null ? _a : null);
  }
  setPullListForRepo(org, repo, params, value) {
    const repoCache = this.getRepoCache(org, repo);
    repoCache.pullListForRepoCache[JSON.stringify(params)] = new CacheEntry(value);
  }
  setPullRequest(org, repo, pullRequest) {
    const pullCache = this.getRepoCache(org, repo).pullCache;
    const existingCache = pullCache[pullRequest.id];
    if (existingCache) {
      const now = /* @__PURE__ */ new Date();
      existingCache.created = now;
      existingCache.value = pullRequest;
    } else {
      pullCache[pullRequest.id] = new CacheEntry(pullRequest);
    }
  }
  getIssueQuery(query) {
    var _a;
    return this.getCacheValue((_a = this.queries.issueCache[query]) != null ? _a : null);
  }
  setIssueQuery(query, result) {
    this.queries.issueCache[query] = new CacheEntry(result);
  }
  getRepoQuery(query) {
    var _a;
    return this.getCacheValue((_a = this.queries.repoCache[query]) != null ? _a : null);
  }
  setRepoQuery(query, result) {
    this.queries.repoCache[query] = new CacheEntry(result);
  }
  getOrgCache(org) {
    let orgCache = this.orgs[org];
    if (!orgCache) {
      orgCache = this.orgs[org] = new OrgCache();
    }
    return orgCache;
  }
  getRepoCache(org, repo) {
    const orgCache = this.getOrgCache(org);
    let repoCache = orgCache.repos[repo];
    if (!repoCache) {
      repoCache = orgCache.repos[repo] = new RepoCache();
    }
    return repoCache;
  }
  getCacheValue(cacheEntry) {
    if (!cacheEntry || cacheEntry.expired) {
      return null;
    } else {
      return cacheEntry.value;
    }
  }
};

// src/github/github.ts
var cache = new Cache();
function getAccount(org) {
  var _a;
  const account = (_a = PluginSettings.accounts.find((acc) => acc.orgs.some((savedOrg) => savedOrg === org))) != null ? _a : PluginSettings.accounts.find((acc) => acc.id === PluginSettings.defaultAccount);
  return account;
}
function getToken(org) {
  const account = getAccount(org);
  return account == null ? void 0 : account.token;
}
async function getIssue2(org, repo, issue) {
  const cachedValue = cache.getIssue(org, repo, issue);
  if (cachedValue) {
    return Promise.resolve(cachedValue);
  }
  const response = await api.getIssue(org, repo, issue, getToken(org));
  cache.setIssue(org, repo, response);
  return response;
}
async function getMyIssues(params, org) {
  const account = getAccount(org);
  if (!account || !account.token) {
    return [];
  }
  const _params = sanitizeObject(params, {
    assignee: false,
    creator: false,
    direction: true,
    labels: true,
    mentioned: false,
    milestone: false,
    page: true,
    per_page: true,
    since: true,
    sort: true,
    state: true,
    filter: true,
    org: false,
    repo: false
  });
  if (Array.isArray(_params.labels)) {
    _params.labels = _params.labels.join(",");
  }
  const cachedValue = cache.getIssueList(account.name, _params);
  if (cachedValue) {
    return Promise.resolve(cachedValue);
  }
  const response = await api.listIssuesForToken(_params, account.token);
  cache.setIssueList(account.name, _params, response);
  return response;
}
async function getIssuesForRepo(params, org, repo) {
  const _params = sanitizeObject(params, {
    assignee: true,
    creator: true,
    direction: true,
    labels: true,
    mentioned: true,
    milestone: true,
    page: true,
    per_page: true,
    since: true,
    sort: true,
    state: true,
    org: false,
    repo: false,
    filter: false
  });
  if (Array.isArray(_params.labels)) {
    _params.labels = _params.labels.join(",");
  }
  const cachedValue = cache.getIssueListForRepo(org, repo, _params);
  if (cachedValue) {
    return Promise.resolve(cachedValue);
  }
  const response = await api.listIssuesForRepo(org, repo, _params, getToken(org));
  cache.setIssueListForRepo(org, repo, _params, response);
  return response;
}
async function getPullRequest2(org, repo, pullRequest) {
  const cachedValue = cache.getPullRequest(org, repo, pullRequest);
  if (cachedValue) {
    return Promise.resolve(cachedValue);
  }
  const response = await api.getPullRequest(org, repo, pullRequest, getToken(org));
  cache.setPullRequest(org, repo, response);
  return response;
}
async function getPullRequestsForRepo(params, org, repo) {
  const _params = sanitizeObject(params, {
    org: false,
    repo: false,
    base: true,
    direction: true,
    head: true,
    page: true,
    per_page: true,
    sort: true,
    state: true
  });
  const cachedValue = cache.getPullListForRepo(org, repo, _params);
  if (cachedValue) {
    return Promise.resolve(cachedValue);
  }
  const response = await api.listPullRequestsForRepo(org, repo, _params, getToken(org));
  cache.setPullListForRepo(org, repo, _params, response);
  return response;
}
async function searchIssues2(query, org) {
  const cachedResponse = cache.getIssueQuery(query);
  if (cachedResponse) {
    return Promise.resolve(cachedResponse);
  }
  const response = await api.searchIssues(query, getToken(org));
  cache.setIssueQuery(query, response);
  return response;
}
async function getPRForIssue(timelineUrl, org) {
  var _a, _b, _c;
  let response = cache.getGeneric(timelineUrl);
  if (response === null) {
    try {
      response = (await githubRequest({ url: timelineUrl }, getToken(org))).json;
    } catch (err) {
      if (err instanceof RequestError && err.status === 404) {
        return null;
      } else {
        throw err;
      }
    }
  }
  if (!response) {
    return null;
  }
  cache.setGeneric(timelineUrl, response);
  const crossRefEvent = response.find((_evt) => {
    var _a2, _b2, _c2;
    const evt = _evt;
    return evt.event === "cross-referenced" && ((_c2 = (_b2 = (_a2 = evt.source) == null ? void 0 : _a2.issue) == null ? void 0 : _b2.pull_request) == null ? void 0 : _c2.html_url);
  });
  return (_c = (_b = (_a = crossRefEvent == null ? void 0 : crossRefEvent.source.issue) == null ? void 0 : _a.pull_request) == null ? void 0 : _b.html_url) != null ? _c : null;
}

// src/github/url-parse.ts
var apiRegex = /(https:\/\/)?api\.github\.com\/repos\//;
function repoAPIToBrowserUrl(urlString) {
  return urlString.replace(apiRegex, "https://github.com/");
}
function parseUrl2(urlString) {
  const url = new URL(urlString);
  const parsedUrl = { url: urlString, host: url.hostname };
  const urlParts = url.pathname.split("/");
  if (urlParts.length >= 4) {
    switch (urlParts[3].toLowerCase()) {
      case "issues":
        if (urlParts[4]) {
          const issueNumber = parseInt(urlParts[4], 10);
          if (!isNaN(issueNumber)) {
            parsedUrl.issue = issueNumber;
          }
        }
        break;
      case "pull":
        if (urlParts[4]) {
          const prNumber = parseInt(urlParts[4], 10);
          if (!isNaN(prNumber)) {
            parsedUrl.pr = prNumber;
          }
        }
        break;
      case "blob":
        parsedUrl.code = {};
        if (urlParts[4]) {
          parsedUrl.code.branch = urlParts[4];
        }
        if (urlParts[5]) {
          const pathParts = urlParts.slice(5);
          parsedUrl.code.path = pathParts.join("/");
        }
        break;
      case "commit":
        if (urlParts[4]) {
          parsedUrl.commit = urlParts.slice(4).join("/");
        }
        break;
    }
  }
  if (urlParts.length >= 3) {
    parsedUrl.repo = urlParts[2];
  }
  if (urlParts.length >= 2) {
    parsedUrl.org = urlParts[1];
  }
  return parsedUrl;
}

// src/inline/inline.ts
var import_obsidian6 = require("obsidian");

// src/icon.ts
var import_obsidian5 = require("obsidian");
function setPRIcon(icon, status) {
  if (status !== "closed" /* Closed */) {
    (0, import_obsidian5.setIcon)(icon, "git-pull-request-arrow");
  } else {
    (0, import_obsidian5.setIcon)(icon, "git-pull-request-closed");
  }
  icon.dataset.status = status;
}
function setIssueIcon(icon, status, reason) {
  if (reason === "not_planned") {
    (0, import_obsidian5.setIcon)(icon, "square-slash");
  } else {
    (0, import_obsidian5.setIcon)(icon, "square-dot");
  }
  icon.dataset.status = status;
}

// src/inline/inline.ts
async function createTag(href) {
  var _a;
  const parsedUrl = parseUrl2(href);
  const container = createEl("a", { cls: "github-link-inline", href });
  const icon = createTagSection(container).createSpan({
    cls: ["github-link-status-icon", "github-link-inline-icon"]
  });
  (0, import_obsidian6.setIcon)(icon, "github");
  if (parsedUrl.repo) {
    createTagSection(container).createSpan({
      cls: "github-link-inline-repo",
      text: parsedUrl.repo
    });
  } else if (parsedUrl.org) {
    createTagSection(container).createSpan({
      cls: "github-link-inline-org",
      text: parsedUrl.org
    });
  }
  if (parsedUrl.repo && parsedUrl.org) {
    if (parsedUrl.issue !== void 0) {
      const issue = await getIssue2(parsedUrl.org, parsedUrl.repo, parsedUrl.issue);
      if (issue.title) {
        (0, import_obsidian6.setIcon)(icon, "square-dot");
        if ((_a = issue.pull_request) == null ? void 0 : _a.merged_at) {
          icon.dataset.status = "done";
        } else {
          icon.dataset.status = issue.state;
        }
        createTagSection(container).createSpan({
          cls: "github-link-inline-issue-title",
          text: issue.title
        });
      }
    }
    if (parsedUrl.pr !== void 0) {
      const pull = await getPullRequest2(parsedUrl.org, parsedUrl.repo, parsedUrl.pr);
      if (pull.title) {
        const status = getPRStatus(pull);
        setPRIcon(icon, status);
        createTagSection(container).createSpan({
          cls: "github-link-inline-pr-title",
          text: pull.title
        });
      }
    }
  }
  return container;
}
function createTagSection(parent) {
  return parent.createDiv({ cls: "github-link-inline-section" });
}
async function InlineRenderer(el) {
  const githubLinks = el.querySelectorAll(`a.external-link[href^="https://github.com"]`);
  for (const anchor of Array.from(githubLinks)) {
    const container = await createTag(anchor.href);
    anchor.replaceWith(container);
  }
}

// src/plugin.ts
var import_obsidian9 = require("obsidian");

// src/query/params.ts
var import_obsidian7 = require("obsidian");
function processParams(source) {
  let params;
  try {
    params = (0, import_obsidian7.parseYaml)(source);
  } catch (e) {
    console.error(`Github Link: YAML Parsing failed, attempting simplistic parsing
${e}`);
    params = Object.fromEntries(source.split("\n").map((l) => l.split(/:\s?/)));
  }
  return params != null ? params : null;
}
function isTableQueryParams(params) {
  return params.outputType === "table" /* Table */ && Boolean(params.query);
}
function isTableParams(params) {
  return params.outputType === "table" /* Table */ && !params.query;
}

// src/query/column/defaults.ts
var DEFAULT_COLUMNS = {
  ["issue" /* Issue */]: ["number", "title", "author", "created", "status"],
  ["pull-request" /* PullRequest */]: ["number", "title", "author", "created", "status"],
  ["repo" /* Repo */]: []
};

// src/query/column/base.ts
function DateCell(value, el) {
  el.classList.add("github-link-table-date");
  if (!value) {
    return;
  }
  const asDate = new Date(value);
  if (isNaN(asDate.valueOf())) {
    el.setText(value);
    return;
  }
  el.setText(DateFormat.DATE_SHORT.format(asDate));
}
var CommonIssuePRColumns = {
  number: {
    header: "Number",
    cell: (row, el) => {
      el.classList.add("github-link-table-issue-number");
      el.createEl("a", { text: `#${row.number}`, href: row.html_url });
    }
  },
  repo: {
    header: "Repo",
    cell: (row, el) => {
      el.classList.add("github-link-table-repo");
      const url = repoAPIToBrowserUrl(row.repository_url);
      const parsed = parseUrl2(url);
      el.createEl("a", { text: parsed.repo, href: url });
    }
  },
  author: {
    header: "Author",
    cell: (row, el) => {
      var _a, _b;
      const anchor = el.createEl("a", { cls: "github-link-table-author" });
      if ((_a = row.user) == null ? void 0 : _a.avatar_url) {
        anchor.createEl("img", { cls: "github-link-table-avatar", attr: { src: row.user.avatar_url } });
      }
      anchor.createSpan({ text: (_b = row.user) == null ? void 0 : _b.login });
    }
  },
  created: {
    header: "Created",
    cell: (row, el) => {
      DateCell(row.created_at, el);
    }
  },
  updated: {
    header: "Updated",
    cell: (row, el) => {
      DateCell(row.updated_at, el);
    }
  },
  closed: {
    header: "Closed",
    cell: (row, el) => {
      DateCell(row.closed_at, el);
    }
  }
};

// src/query/column/issue.ts
var IssueColumns = {
  ...CommonIssuePRColumns,
  status: {
    header: "Status",
    cell: (row, el) => {
      const wrapper = el.createDiv({ cls: "github-link-table-status" });
      const status = getSearchResultIssueStatus(row);
      const icon = wrapper.createSpan({ cls: "github-link-status-icon" });
      setIssueIcon(icon, status, row.state_reason);
      wrapper.createSpan({ text: row.state_reason === "not_planned" ? "Not Planned" : titleCase(status) });
    }
  },
  pr: {
    header: "PR",
    cell: async (row, el) => {
      if (!row.timeline_url) {
        return;
      }
      const pullRequestUrl = await getPRForIssue(row.timeline_url);
      if (!pullRequestUrl) {
        return;
      }
      const tag = await createTag(pullRequestUrl);
      el.appendChild(tag);
    }
  }
};

// src/query/column/pull-request.ts
var PullRequestColumns = {
  ...CommonIssuePRColumns,
  status: {
    header: "Status",
    cell: (row, el) => {
      const wrapper = el.createDiv({ cls: "github-link-table-status" });
      const status = getSearchResultIssueStatus(row);
      const icon = wrapper.createSpan({ cls: "github-link-status-icon" });
      setPRIcon(icon, status);
      wrapper.createSpan({ text: status === "done" /* Done */ ? "Merged" : titleCase(status) });
    }
  }
};

// src/query/column/repo.ts
var RepoColumns = {};

// src/query/output.ts
var ALL_COLUMNS = {
  ["pull-request" /* PullRequest */]: PullRequestColumns,
  ["issue" /* Issue */]: IssueColumns,
  ["repo" /* Repo */]: RepoColumns
};
async function renderTable(params, result, el) {
  var _a, _b;
  const table = el.createEl("table", { cls: "github-link-table" });
  const thead = table.createEl("thead");
  let columns = params.columns;
  if (!columns || columns.length === 0) {
    columns = DEFAULT_COLUMNS[params.queryType];
  }
  for (const col of columns) {
    const th = thead.createEl("th");
    th.setText((_b = (_a = ALL_COLUMNS[params.queryType][col]) == null ? void 0 : _a.header) != null ? _b : titleCase(col));
  }
  const tbody = table.createEl("tbody");
  const items = Array.isArray(result) ? result : result.items;
  for (const row of items) {
    const tr = tbody.createEl("tr");
    for (const col of columns) {
      const cell = tr.createEl("td");
      const renderer = ALL_COLUMNS[params.queryType][col];
      if (renderer) {
        renderer.cell(row, cell);
      } else {
        const cellVal = getProp(row, col);
        if (cellVal !== null) {
          cell.setText(typeof cellVal === "string" ? cellVal : JSON.stringify(cellVal));
        } else {
          cell.setText("");
        }
      }
    }
  }
}

// src/query/processor.ts
async function QueryProcessor(source, el, _ctx) {
  const params = processParams(source);
  if (!params) {
    el.setText(source);
    return;
  }
  if (isTableQueryParams(params)) {
    if (params.queryType === "issue" /* Issue */ || params.queryType === "pull-request" /* PullRequest */) {
      const response = await searchIssues2(params.query);
      renderTable(params, response, el);
    }
  } else if (isTableParams(params)) {
    if (params.queryType === "issue" /* Issue */) {
      const issueParams = params;
      if (issueParams.org && issueParams.repo) {
        const response = await getIssuesForRepo(issueParams, issueParams.org, issueParams.repo);
        renderTable(params, response, el);
      } else {
        const response = await getMyIssues(issueParams, issueParams.org);
        renderTable(params, response, el);
      }
    } else if (params.queryType === "pull-request" /* PullRequest */) {
      Logger.debug("Rendering pull table...");
      const pullParams = params;
      if (pullParams.org && pullParams.repo) {
        const response = await getPullRequestsForRepo(pullParams, pullParams.org, pullParams.repo);
        Logger.debug("Got PRs");
        Logger.debug(response);
        renderTable(params, response, el);
      }
    }
  }
}

// src/inline/view-plugin.ts
var import_obsidian8 = require("obsidian");
var import_view = require("@codemirror/view");
var InlineTagWidget = class extends import_view.WidgetType {
  constructor(href, dispatch) {
    super();
    this.href = href;
    this.error = false;
    this.container = createSpan();
    createTag(href).then((tag) => {
      this.container.appendChild(tag);
    }).catch((err) => {
      console.error(err);
      this.error = true;
      dispatch();
    });
  }
  eq(widget) {
    return widget.href === this.href;
  }
  toDOM() {
    return this.container;
  }
};
function createInlineViewPlugin(_plugin) {
  class InlineViewPluginValue {
    constructor(view) {
      this.match = new import_view.MatchDecorator({
        regexp: /(https:\/\/)?github\.com[\S]+/g,
        decorate: (add, from, to, match, view) => {
          const shouldRender = this.shouldRender(view, from, to);
          if (shouldRender) {
            add(
              from,
              to,
              import_view.Decoration.replace({
                widget: new InlineTagWidget(match[0], view.dispatch)
              })
            );
          }
        }
      });
      this.decorations = import_view.Decoration.none;
      this.view = view;
      this.updateDecorations(view);
    }
    update(update) {
      this.updateDecorations(update.view, update);
    }
    destroy() {
      this.decorations = import_view.Decoration.none;
    }
    updateDecorations(view, update) {
      if (!update || this.decorations.size === 0) {
        this.decorations = this.match.createDeco(view);
      } else {
        this.decorations = this.match.updateDeco(update, this.decorations);
      }
    }
    isLivePreview(state) {
      return state.field(import_obsidian8.editorLivePreviewField);
    }
    shouldRender(view, decorationFrom, decorationTo) {
      const overlap = view.state.selection.ranges.some((r) => {
        if (r.from <= decorationFrom) {
          return r.to >= decorationFrom;
        } else {
          return r.from <= decorationTo;
        }
      });
      return !overlap && this.isLivePreview(view.state);
    }
  }
  const InlineViewPluginSpec = {
    decorations: (plugin) => {
      return plugin.decorations.update({
        filter: (rangeFrom, rangeTo, deco) => {
          const widget = deco.spec.widget;
          if (widget && widget.error) {
            return false;
          }
          return rangeFrom === rangeTo || // Check if there are no overlapping selection ranges
          !plugin.view.state.selection.ranges.filter((selectionRange) => {
            const selectionStart = selectionRange.from;
            const selectionEnd = selectionRange.to;
            if (selectionStart <= rangeFrom) {
              return selectionEnd >= rangeFrom;
            } else {
              return selectionStart <= rangeTo;
            }
          }).length;
        }
      });
    }
  };
  return import_view.ViewPlugin.fromClass(InlineViewPluginValue, InlineViewPluginSpec);
}

// src/plugin.ts
var PluginSettings = { ...DEFAULT_SETTINGS };
var Logger = verboseFactory(0 /* Error */);
var GithubLinkPlugin = class extends import_obsidian9.Plugin {
  async onload() {
    PluginSettings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    Logger = verboseFactory(PluginSettings.logLevel);
    this.addSettingTab(new GithubLinkPluginSettingsTab(this.app, this));
    this.registerMarkdownPostProcessor(InlineRenderer);
    this.registerEditorExtension(createInlineViewPlugin(this));
    this.registerMarkdownCodeBlockProcessor("github-query", QueryProcessor);
  }
};

// main.ts
var main_default = GithubLinkPlugin;
